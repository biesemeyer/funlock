/*
 * This source file was generated by the Gradle 'init' task
 */
package net.biesemeyer.funlock;

import com.google.common.primitives.Primitives;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.lang.ref.WeakReference;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Supplier;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;
import static org.junit.jupiter.api.Assertions.*;

public class WeakrefRegistryTest {

    @Test
    public void testContinuity() throws Exception  {
        final TestableWeakrefRegistry<Key, Value> registry = new TestableWeakrefRegistry<>(Key.class, Value::new);

        final Key key = new Key("key");

        assertThat(registry.get(key), is(sameInstance(registry.get(key))));
    }

    @Test
    public void testEquivalentKeysResolveDifferently() throws Exception  {
        final TestableWeakrefRegistry<Key, Value> registry = new TestableWeakrefRegistry<>(Key.class, Value::new);

        final Key keyOne = new Key("key");
        final Key keyTwo = new Key("key");

        assertThat("precondition", keyOne, is(equalTo(keyTwo)));
        assertThat(registry.get(keyOne), is(not(sameInstance(registry.get(keyTwo)))));
    }

    @Test
    public void testIdentityMapping() throws Exception {
        final TestableWeakrefRegistry<Key, Value> registry = new TestableWeakrefRegistry<>(Key.class, Value::new);

        final Key keyOne = new Key("keyOne");
        final Key keyTwo = new Key("keyTwo");
        assertThat(registry.get(keyOne), is(not(sameInstance(registry.get(keyTwo)))));

        final Key keyOneDuplicate = new Key("keyOne");
        assertThat("precondition", keyOneDuplicate, is(equalTo(keyOne)));
        assertThat(registry.get(keyOneDuplicate), is(not(sameInstance(registry.get(keyOne)))));
    }

    @Test
    public void testCleanupWhenKeyGoesOutOfScope() throws Exception {
        final TestableWeakrefRegistry<Key, Value> registry = new TestableWeakrefRegistry<>(Key.class, Value::new);

        final Key keyOne = new Key("keyOne");
        final Value valueOne = registry.get(keyOne);
        assertThat("precondition", registry.containsValue(valueOne), is(true));

        Key keyTwo = new Key("keyTwo");
        final WeakReference<Key> keyTwoRef = new WeakReference<>(keyTwo);
        final Value valueTwo = registry.get(keyTwo);

        assertThat(registry.containsValue(valueTwo), is(true));
        keyTwo = null; // be free little key

        assertTrue(blockUntil(() -> {
            System.gc();
            return Objects.isNull(keyTwoRef.get());
        }, Duration.ofSeconds(10)), "precondition: keyTwo is Garbage Collected");

        final Key keyThree = new Key("keyThree");
        final Value valueThree = registry.get(keyThree);

        assertThat(registry.containsValue(valueOne), is(true));
        assertThat(registry.containsValue(valueTwo), is(false));
        assertThat(registry.containsValue(valueThree), is(true));
    }

    @ParameterizedTest
    @ValueSource(classes = { byte.class, short.class, int.class, long.class, float.class, double.class, boolean.class, char.class, void.class })
    public void testProhibitPrimitiveKey(final Class<?> clazz) throws Exception {

        final IllegalArgumentException iae = assertThrows(IllegalArgumentException.class, () -> { new TestableWeakrefRegistry<>(clazz, Object::new); });
        assertThat(iae.getMessage(), containsString("must not be primitive"));
    }

    @ParameterizedTest
    @ValueSource(classes = { Object.class, String.class, Collection.class, Map.class })
    public void testProhibitJavaPackageKey(final Class<?> clazz) throws Exception {
        final IllegalArgumentException iae = assertThrows(IllegalArgumentException.class, () -> { new TestableWeakrefRegistry<>(clazz, Object::new); });
        assertThat(iae.getMessage(), containsString("key type must be from package outside Java core"));
    }

    private boolean blockUntil(final Supplier<Boolean> condition, final Duration timeout) throws InterruptedException {
        final long timeoutNanos = timeout.toNanos();
        final long startNanos = System.nanoTime();
        while ((System.nanoTime() - startNanos) < timeoutNanos) {
            if (condition.get()) {
                return true;
            }
            //noinspection BusyWait
            Thread.sleep(10);
        }
        return condition.get();
    }

    private static class TestableWeakrefRegistry<K,V> extends AbstractWeakrefRegistry<K, V> {
        public TestableWeakrefRegistry(Class<K> keyClass, Supplier<V> lockFactory) {
            super(keyClass, lockFactory);
        }

        @Override
        public <E extends Exception> void runWithInstance(K key, Checked.Consumer<V, E> lockHandler) throws E {
            super.runWithInstance(key, lockHandler);
        }

        @Override
        public <R, E extends Exception> R getWithInstance(K key, Checked.Function<V, R, E> lockHandler) throws E {
            return super.getWithInstance(key, lockHandler);
        }
    }

    private static class Key {

        private final String key;
        public Key(String key) {
            this.key = key;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Key key1 = (Key) o;
            return Objects.equals(key, key1.key);
        }

        @Override
        public int hashCode() {
            return Objects.hashCode(key);
        }

        @Override
        public String toString() {
            return "Key{" + key + '}';
        }
    }

    private static class Value {
        AtomicLong counter = new AtomicLong();

        private final long id = counter.incrementAndGet();
        private final AtomicLong entries = new AtomicLong();
        private final AtomicLong exits = new AtomicLong();

        public <R, E extends Exception> R getRecorded(Checked.Supplier<R, E> supplier) throws E {
            this.entries.incrementAndGet();
            final R r = supplier.get();
            this.exits.incrementAndGet();
            return r;
        }

        public <E extends Exception> void runRecorded(Checked.Runnable<E> runnable) throws E {
            this.getRecorded(() -> {
                runnable.run();
                return null;
            });
        }
    }

}
